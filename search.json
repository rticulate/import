[{"path":"/articles/import.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The import package","text":"One important aspects R ecosystem ease extensions new features can developed distributed form packages. main distribution channel Comprehensive R Archive Network, packages can installed directly R. Another popular option using GitHub repositories packages can also painlessly installed, e.g. using install_github devtools package. import package provides alternative approach using external functionality R scripts; first however, useful describe standard approach clarify import may serve improvement. common way include functionality provided package use library function: situations fine; however subtle shortcomings: Packages attached exported objects exposed, using packages way, order attached can important, quickly becomes unclear reader script package certain functionality comes , terms “library” “package” often used incorrectly (although minor point, seems confuse somewhat). problem (1) search path populated objects needed immediately clear whether name clashes occur. Problem (2) refers case packages export different objects names, say function_b exported PackageA PackageB . case name point object package attached last. earlier exposed objects said masked. Even problem writing script, update packages may cause problem later executing script; tracking resulting errors may tough time consuming. Problem (3) may appear unimportant, underestimated. Code snippets commonly shared spending time figuring functionality comes satisfying value-adding activity. possible unambiguously specify function comes prefixing :: every time used, often overly verbose provide easily accessible overview external functionality used script. One may also import single exported objects, one time, using (double) “colon syntax”, downside approach object placed user’s global work space, rather encapsulated somewhere else search path (using library load pkg, namespace package:pkg attached search path contain exported functions pkg). Another minor point one can import one object time using approach. packages form backbone code distribution, another option comes form scripts, usually task specific commonly used “bundle” functionality use scripts. particular, source used include contents one script another, objects produced script “exposed” may “populate” working environment, masking objects, producing mental clutter. Scope management therefore comfortable splitting functionality across files modular way. import package sets improve way external functionality included code alleviating concerns raised providing expressive way importing object packages scripts. latter provides bridge package approach distribution simple stand-alone script files. allows use scripts modules, collection related object definitions, may used different places without exposing necessary. package inspired part Python’s some_module import some_function syntax, solves two issues raised . also similar roxygen2s @importFrom package function1 function2 packages. import also work package development, intended use case using external functions R scripts. addition able import objects packages, import also allows import objects scripts (.e. kind module). allows simple way distribute use functionality without need write full package. One example Shiny app, one can place definitions script import needed objects used. avoids workspace clutter name clashes. details see .","code":"library(PackageA) library(PackageB)  value1 <- function_a(...) # Supposedly this comes from PackageA,  value2 <- function_b(...) # and this from PackageB, but who knows?! ... function_a <- PackageA::function_a function_b <- PackageB::function_b"},{"path":[]},{"path":"/articles/import.html","id":"importing-from-packages","dir":"Articles","previous_headings":"Basic Usage","what":"Importing from Packages","title":"The import package","text":"basic use case import functions package (psych package): imported objects placed separate entity search path default named “imports”. therefore also easy get rid detach(\"imports\"). main point clear functions used come . ’s noteworthy nothing special going : import::function convenient wrapper around getExportedValue (:: ) assign. import package attached (don’t include via library, get warning). Rather, designed expressive using colon syntax. import non-exported objects one must use triple-colon syntax: import:::(pkg, obj). import functions called regularly, .e. without preceding import:: import:::, error raised. import attached, startup message inform import attached. one function names conflicts existing function (filter dplyr package) simple rename : pretty much says: three functions imported dplyr, two keep original name, one renamed, e.g. avoid name clash stats::filter. can use .=TRUE import functions package, rename one : omit function import, use .except (takes character vector): Note import tries smart assumes using .except parameter, probably want import everything explicitly omitting, sets .parameter TRUE. can override exceptional cases, seldom need . Finally, complex example, combining different import statements: , clear package provides functions (one e.g. otherwise tempted think tidy belonged tidyr). Note ordering irrelevant, even tidyr point exposes function tidy update, import explicit importing. also shows one can import multiple objects single statement, even rename objects desired; example, one can imagine filter stats needed later , dplyr’s filter renamed avoid confusion. Sometimes, clear purpose package ; e.g. name magrittr immediately reveal ’s main purpose provide pipe operator, %>%.","code":"import::from(psych, geometric.mean, harmonic.mean) geometric.mean(trees$Volume) import::from(dplyr, select, arrange, keep_when = filter) keep_when(mtcars, hp>250) import::from(dplyr, keep_when = filter, .all=TRUE) import::from(dplyr, .except=c(\"filter\", \"lag\")) import::from(magrittr, \"%>%\") import::from(dplyr, starwars, select, mutate, keep_when = filter) import::from(tidyr, unnest) import::from(broom, tidy)  ready_data <-   starwars %>%    keep_when(mass < 100) %>%    select(name, height, mass, films) %>%   unnest(films) %>%   mutate( log_mass = log(mass), films=factor(films))  linear_model <-    lm(log_mass ~ height + films, data = ready_data) %>%    tidy"},{"path":"/articles/import.html","id":"module","dir":"Articles","previous_headings":"Basic Usage > Importing from Packages","what":"Importing Functions from “Module” Scripts","title":"The import package","text":"import package allows importing objects defined script files, refer “modules”. module fully evaluated import import requested, objects functions data can imported. modules side-effect free, enforced. Attachments detached (e.g. packages attached library) loaded namespaces remain loaded. means values created functions attached namespace work import, functions exported rely functions (use function importing modules instead). example, file sequence_module.R contains several functions calculating terms mathematical sequences. possible import files, just one imports packages: Renaming, ., .except parameters work way packages: module modified, import realize reload script imports executed re-executed; otherwise additional imports cause script reloaded efficiency. script loaded environment (maintained import) dependencies kept (except exposed attachment), following small example shows. Contents “some_module.R”: Usage: Suppose related functionality wish bundle, authoring full package seems excessive inappropriate specific task, example bundling related user interface components shiny application. One option import author module (script), say outlined : another file need fun_c: , fun_c visible inside bar.R. functions depends exist, exposed. Also, note imported scripts may import. Since desired effect import::inside module script ambiguous, results warning (functions still imported local environment script, just import::imports exposed module . importing module, sourced environment managed import, sourced upon subsequent imports (unless file changed). example, shiny application, importing objects server.R others ui.R module cause sourced twice.","code":"import::from(sequence_module.R, fibonacci, square, triangular) import::from(sequence_module.R, fib=fibonacci, .except=\"square\") ## Do not use library() inside a module. This results in a warning,  ## and functions relying on ggplot2 will not work. #library(ggplot2)  ## This is also not recommended, because it is not clear wether recursively  ## imported functions should be available after the module is imported #import::here(qplot, .from = ggplot2)  ## This is the recommended way to recursively import functions on which ## module functions depend. The qplot function will be available to  ## module functions, but will not itself be available after import import::here(qplot, .from = ggplot2)  ## Note this operator overload is not something you want to `source`! `+` <- function(e1, e2)   paste(e1, e2)  ## Some function relying on the above overload: a <- function(s1, s2)   s1 + rep(s2, 3)  ## Another value. b <- head(iris, 10)  ## A value created using a recursively imported function p <- qplot(Sepal.Length, Sepal.Width, data = iris, color = Species)  ## A function relying on a function exposed through attachment: plot_it <- function()   qplot(Sepal.Length, Sepal.Width, data = iris, color = Species) import::from(some_module.R, a, b, p, plot_it)  ## Works: a(\"cool\", \"import\")  ## The `+` is not affecting anything here, so this won't work: # \"cool\" + \"import\"  # Works: b p plot_it() # File: foo.R # Desc: Functionality related to foos. # Imports from other_resources.R # When recursively importing from another module or package for use by  # your module functions, you should always use import::here() rather  # than import::from() or library() import::here(fun_a, fun_b, .from = \"other_resources.R\")  internal_fun <- function(...) ...  fun_c <- function(...)  {   ...   a <- fun_a(...)   i <- internal_fun(...)   ... }  fun_d <- function(...) ... # File: bar.R # Desc: Functionality related to bars.  # Imports from foo.R import::here(fun_c, .from = \"foo.R\") ..."},{"path":"/articles/import.html","id":"choosing-where-import-looks-for-packages-or-modules","dir":"Articles","previous_headings":"Basic Usage > Importing from Packages","what":"Choosing where import looks for packages or modules","title":"The import package","text":"import package default use current set library paths, .e. result .libPaths(). , however, possible specify different set library paths using .library argument import functions, example import packages installed custom location, remove ambiguity imports come . Note versions including 1.3.0 defaulted use first entry library paths, .e. .library=.libPaths()[1L]. believe new default applicable broader set circumstances, change causes issues, much appreciate hearing . importing module (.R file), directory import looks module script can specified .directory parameter. default . (current working directory).","code":""},{"path":"/articles/import.html","id":"choosing-where-the-imported-functions-are-placed","dir":"Articles","previous_headings":"Basic Usage > Importing from Packages","what":"Choosing where the imported functions are placed","title":"The import package","text":"One can also specify names use search path use several group imports. Names can specified either character literals variables type character (example environment needs determined dynamically). import::import::accept parameters achieve result. choice matter preference). using custom search path entities actively, one might prefer alternative syntax (reverses argument order): aware beginning version 1.3.0 hidden objects (names prefixed period) supported. Take care avoid name clashes argument names. desired import objects directly current environment, can accomplished import::. particularly useful importing inside function definition, module scripts described . Instead specifying named environment search path, passing character .parameter, possible directly specify environment. function automatically determines use case involved, based mode() .parameter (either character environment). Prior version 1.3.0, non-standard evaluation (NSE) applied .parameter, necessary surround {}, order treated environment. longer needed, although still allowed (curly brackets simply ignored). Examples include:","code":"import::from(magrittr, \"%>%\", \"%$%\", .into = \"operators\") import::from(dplyr, arrange, .into = \"datatools\") import::from(psych, describe, .into=month.name[1]) # Uses env: \"January\" import::into(\"operators\", \"%>%\", \"%$%\", .from = magrittr) import::into(\"datatools\", arrange, .from = dplyr) import::into(month.name[1], describe, .from=psych) import::here(\"%>%\", \"%$%\", .from = magrittr) import::here(arrange, .from = dplyr) # Import into the local environment import::into(environment(), \"%>%\", .from = magrittr)  # Import into the global environment, curlies are optional import::into({.GlobalEnv}, \"%>%\", \"%$%\", .from = magrittr)  # Import into a new environment, mainly useful for python-style imports # (see below) x = import::into(new.env(), \"%<>%\", .from = magrittr)"},{"path":[]},{"path":"/articles/import.html","id":"advanced-usage-and-the--character_only-parameter","dir":"Articles","previous_headings":"Advanced usage","what":"Advanced usage and the .character_only parameter","title":"The import package","text":"import package uses non-standard evaluation (NSE) .... parameters, allowing names packages functions listed without quoting . makes common use-cases straightforward, can get way programmatic usages. .character_only parameter comes handy. setting .character_only=TRUE, non-standard evaluation .... parameters disabled. Instead, parameters processed character vectors containing relevant values. (Previously, NSE also applied .parameter, version 1.3.0 longer case, parameters except .... always evaluated standard way.) useful examine examples specifying .character_only=TRUE can helpful.","code":""},{"path":"/articles/import.html","id":"programmatic-selection-of-objects-to-import","dir":"Articles","previous_headings":"Advanced usage","what":"Programmatic selection of objects to import","title":"The import package","text":"always know advance objects import given package. example, assume list objects broom package need import, can follows: import three functions specified objects vector. worth noting .character_only disables non-standard evaluation parameters, name package must now quoted. One common use case one wants import objects except one , conflicts packages. one, example, want use stats versions filter() lag() functions, import functions dplyr package, one like :","code":"objects <- c(\"tidy\", \"glance\", \"augment\") import::from(\"broom\", objects, .character_only=TRUE) objects <- setdiff(getNamespaceExports(\"dplyr\"), c(\"filter\",\"lag\")) import::from(\"dplyr\", objects, .character_only=TRUE)"},{"path":"/articles/import.html","id":"programmatic-selection-of-module-location","dir":"Articles","previous_headings":"Advanced usage","what":"Programmatic selection of module location","title":"The import package","text":"approach can used directory source file module known advance. can useful original source file always run original working directory, one still want specify hard-coded absolute path, determine run time: , note now name function must quoted non-standard evaluation disabled parameters. package useful many circumstances like ; allows setting “root” directory project using ::() function figure correct directory, regardless working directory. Alternatively, file name always directory differs, use .directory parameter, always expects standard evaluation arguments. Note ::() relation import::() despite similarity names.","code":"mymodule <- file.path(mypath, \"module.R\") import::from(mymodule, \"myfunction\", .character_only=TRUE) import::from(here::here(\"src/utils/module.R\")), \"myfunction\", .character_only=TRUE) import::from(module.R, \"myfunction\", here::here(\"src/utils\"))"},{"path":"/articles/import.html","id":"importing-from-a-url","dir":"Articles","previous_headings":"Advanced usage","what":"Importing from a URL","title":"The import package","text":"Another case .character_only comes handy one wants import functions URL. import allow direct importing URL (difficult questions URL target changes, whether download file things), easy achieve desired result using pins package (whose main purpose resolve difficult questions). simple example follows, directly imports myfunc() function, defined plusone_module.R:","code":"url <- \"https://raw.githubusercontent.com/rticulate/import/master/man/examples/plusone_module.R\" import::from(pins::pin(url), \"myfunc\", .character_only=TRUE) myfunc(3) #> [1] 4"},{"path":"/articles/import.html","id":"python-like-imports","dir":"Articles","previous_headings":"Advanced usage","what":"Python-like imports","title":"The import package","text":"frequent pattern python imports packages alias; subsequent use imported objects explicitly includes alias: order achieve functionality import package, use .={new.env()} assign new environment without attaching . import::() returns environment, can assigned variable:","code":"import pandas as pd import numpy as np import math as m  print(m.pi) print(m.e) # Import into a new namespace, use $ to access td <- import::from(tidyr, spread, pivot_wider, .into={new.env()}) dp <- import::from(dplyr, .all=TRUE, .into={new.env()}) dp$select(head(cars),dist) #>   dist #> 1    2 #> 2   10 #> 3    4 #> 4   22 #> 5   16 #> 6   10  # Note that functions are not visible without dp$ prefix select(head(cars),dist) #> Error in select(head(cars), dist): could not find function \"select\""},{"path":"/articles/import.html","id":"importing-s3-methods","dir":"Articles","previous_headings":"Advanced usage","what":"Importing S3 methods","title":"The import package","text":"S3 methods work well local context, method called different environment, must registered (packages, done NAMESPACE file). import can now register methods form generic.class generic.class.name automatically using new .S3 argument. specifying .S3=TRUE, import automatically detect methods existing new generics. need export /register manually! Consider following script foo.r generic two methods: Now, need import foo generic: experimental feature. think work well encouraged use report back – syntax semantics may change future improve feature.","code":"# foo.r # functions with great foonctionality foo = function(x){   UseMethod(\"foo\", x) }  foo.numeric <- function(x){   x + 1 }  foo.character <- function(x){   paste0(\"_\", x, \"_\") } import::from(\"foo.r\", foo, .S3=TRUE)  foo(0) # 1 foo(\"bar\") # _bar_"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Stefan Milton Bache. Author. Magnus Thor Torfason. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bache S, Torfason M (2025). import: Import Mechanism R. R package version 1.3.2.9001, https://rticulate.github.io/import/.","code":"@Manual{,   title = {import: An Import Mechanism for R},   author = {Stefan Milton Bache and Magnus Thor Torfason},   year = {2025},   note = {R package version 1.3.2.9001},   url = {https://rticulate.github.io/import/}, }"},{"path":[]},{"path":"/index.html","id":"an-import-mechanism-for-r","dir":"","previous_headings":"","what":"An Import Mechanism For R","title":"An Import Mechanism for R","text":"import package intended simplify way functions external packages modules made available use R scripts. Learn package website, reading vignette(\"import\"), using help (?import::).","code":""},{"path":"/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"An Import Mechanism for R","text":"typical way using functionality exposed package R scripts load (attach) entire package library() (require()). can undesirable effect masking objects user’s search path can also make difficult confusing identify functionality comes package using several library statements. import package provides simple alternative, allowing user specify concise way exactly objects. example, Hmisc package exposes four hundred functions. Instead exposing functions, someone needs access , say impute() nomiss() functions, can import functions : motivation behind package, see vignette(“import”)","code":"import::from(Hmisc, impute, nomiss)"},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An Import Mechanism for R","text":"Install release version import CRAN using pak install.packages(): Install development version import GitHub using pak devtools:","code":"pak::pak(\"import\")   # or install.packages(\"import\") pak::pak(\"rticulate/import\")   # or devtools::install_github(\"rticulate/import\")"},{"path":[]},{"path":"/index.html","id":"importing-functions-from-r-packages","dir":"","previous_headings":"Usage","what":"Importing functions from R packages","title":"An Import Mechanism for R","text":"basic use case import functions package (psych package): one function names conflicts existing function (filter dplyr package) simple rename : Use .=TRUE import functions package. want rename one , can still : omit function import, use .except (takes character vector): Note import tries smart assumes using .except parameter, probably want import everything explicitly omitting, sets .parameter TRUE. can still override exceptional cases, seldom need . examples discussed detail Importing Packages section package vignette.","code":"import::from(psych, geometric.mean, harmonic.mean) geometric.mean(trees$Volume) import::from(dplyr, select, arrange, keep_when = filter) keep_when(mtcars, hp>250) import::from(dplyr, keep_when = filter, .all=TRUE) import::from(dplyr, .except=c(\"filter\", \"lag\"))"},{"path":"/index.html","id":"importing-functions-from-module-scripts","dir":"","previous_headings":"Usage","what":"Importing Functions from “Module” Scripts","title":"An Import Mechanism for R","text":"import package allows R files used “modules” functions loaded. example, file sequence_module.R contains several functions calculating terms mathematical sequences. possible import files, just one imports packages: Renaming, well ..except parameters, work way packages: examples discussed detail Importing Modules section package vignette.","code":"import::from(sequence_module.R, fibonacci, square, triangular) import::from(sequence_module.R, fib=fibonacci, .except=\"square\")"},{"path":"/index.html","id":"choosing-where-import-looks-for-packages-or-modules","dir":"","previous_headings":"Usage","what":"Choosing where import looks for packages or modules","title":"An Import Mechanism for R","text":"import package default use current set library paths, .e. result .libPaths(). , however, possible specify different set library paths using .library argument import functions, example import packages installed custom location, remove ambiguity imports come . Note versions including 1.3.0 defaulted use first entry library paths, .e. .library=.libPaths()[1L]. believe new default applicable broader set circumstances, change causes issues, much appreciate hearing . importing module (.R file), directory import looks module script can specified .directory parameter. default . (current working directory).","code":""},{"path":"/index.html","id":"choosing-where-the-imported-functions-are-placed","dir":"","previous_headings":"Usage","what":"Choosing where the imported functions are placed","title":"An Import Mechanism for R","text":"default, imported objects placed separate entity search path called “imports”. One can also specify names use search path use several group imports: using custom search path entities actively, one might prefer alternative syntax (reverses argument order): desired place imported objects current environment, use import::():","code":"import::from(magrittr, \"%>%\", \"%$%\", .into = \"operators\")  import::from(dplyr, arrange, .into = \"datatools\") import::into(\"operators\", \"%>%\", \"%$%\", .from = magrittr) import::into(\"datatools\", arrange, .from = dplyr)"},{"path":"/index.html","id":"more-advanced-usage","dir":"","previous_headings":"Usage","what":"More advanced usage","title":"An Import Mechanism for R","text":"import package designed simple use basic cases, uses symbolic evaluation allow names packages, modules functions entered without quotes (except operators, \"%>%\" must quoted). However, means calling variable containing name module, vector functions import, work. use case, can use .character_only parameter: .character_only parameter covered detail Advanced Usage section package vignette, also describes can import module scripts stored online help pins package, achieve python-like imports help {} notation environments .parameter.","code":"module_name <- \"../utils/my_module.R\"  # Will not work (import will look for a package called \"module_name\") import::from(module_name, foo, bar)  # This will correctly import the foo() and bar() functions from \"../utils/my_module.R\" import::from(module_name, foo, bar, .character_only=TRUE)"},{"path":"/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"An Import Mechanism for R","text":"Contributions project welcome. Please start opening issue discussion thread. New features added conservatively based supply (anyone willing contribute implementation feature?), demand (many people seem need new feature?), last, least, whether feature can implemented without breaking backwards compatibility. Created authored @smbache Currently maintained @torfason Code contributions @awong234, @brshallo, @flying-sheep, @hutch3232, @J-Moravec, @klmr, @mschilli87, @olivroy @aramirezreyes (forget add ? , please let us know!)","code":""},{"path":"/index.html","id":"see-also","dir":"","previous_headings":"","what":"See also:","title":"An Import Mechanism for R","text":"use cases import can now handled directly base R using new exclude include.arguments library() require() interesting slightly different idea Python-like modules R, see box package @klmr (previously called modules). Another approach, focused treating use functions naming conflicts explicit errors conflicted package @hadley.","code":""},{"path":"/reference/import.html","id":null,"dir":"Reference","previous_headings":"","what":"An Import Mechanism for R — import","title":"An Import Mechanism for R — import","text":"alternative mechanism importing objects packages. syntax allows importing multiple objects package single command expressive way. import package bridges gap using library (require) direct (single-object) imports. Furthermore imported objects placed current environment (although possible), named entry search path.","code":""},{"path":"/reference/import.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"An Import Mechanism for R — import","text":"package intended use library. named make calls like import::(pkg, fun1, fun2) expressive. Using import functions complements standard use library(pkg)(objects needed, context clear) obj <- pkg::obj (single object needed).","code":""},{"path":[]},{"path":"/reference/import.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"An Import Mechanism for R — import","text":"Stefan Milton Bache","code":""},{"path":"/reference/importfunctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Import Objects From a Package. — from","title":"Import Objects From a Package. — from","text":"import::import::functions provide alternative way import objects (e.g. functions) packages. sometimes preferred using library (require) import objects exported package. benefit obj <- pkg::obj imported objects (default) placed separate entry search path (can specified), rather global/current environment. Also, succinct way importing several objects. Note two functions symmetric, usage matter preference whether specifying .argument desired. function import::imports current environment.","code":""},{"path":"/reference/importfunctions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import Objects From a Package. — from","text":"","code":"from(   .from,   ...,   .into = \"imports\",   .library = .libPaths(),   .directory = \".\",   .all = (length(.except) > 0),   .except = character(),   .chdir = TRUE,   .character_only = FALSE,   .S3 = FALSE )  here(   .from,   ...,   .library = .libPaths()[1L],   .directory = \".\",   .all = (length(.except) > 0),   .except = character(),   .chdir = TRUE,   .character_only = FALSE,   .S3 = FALSE )  into(   .into,   ...,   .from,   .library = .libPaths()[1L],   .directory = \".\",   .all = (length(.except) > 0),   .except = character(),   .chdir = TRUE,   .character_only = FALSE,   .S3 = FALSE )"},{"path":"/reference/importfunctions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Import Objects From a Package. — from","text":".package import. ... Names name-value pairs specifying objects import. arguments named, imported object new name. .environment imported objects assigned. value mode character, treated referring named environment search path. mode environment, objects assigned directly environment. Using .=environment() causes imports made current environment; .=\"\" equivalent shorthand value. .library character specifying library use importing packages. Defaults current set library paths (note default value different versions including 1.3.0). .directory character specifying directory use importing modules. Defaults current working directory. .module specified using absolute path (.e. starting /), parameter ignored. .logical specifying whether available objects package module  imported. defaults FALSE unless .exclude used omit particular functions. .except character vector specifying objects imported. values specified override values provided ... objects included .parameter .chdir logical specifying whether change directories sourcing module (parameter ignored libraries) .character_only logical indicating whether .... can assumed character strings. (Note parameter apply .parameter handled). .S3 logical indicating whether automatic detection registration S3 methods performed. S3 methods assumed standard form generic.class. Methods can also registered manually instead using registered manually instead using .S3method(generic, class, method) call.  experimental feature. think work well encouraged use report back – syntax semantics may change future improve feature.","code":""},{"path":"/reference/importfunctions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Import Objects From a Package. — from","text":"reference environment containing imported objects.","code":""},{"path":"/reference/importfunctions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Import Objects From a Package. — from","text":"function arguments can quoted unquoted e.g. library. case, character representation used unquoted arguments provided (value objects matching names). period argument names ..avoid name clash package objects. However, importing hidden objects (names prefixed period) supported, care taken conflict argument names. double-colon syntax import::allows imports exported objects (lazy data) . import objects exported, use triple-colon syntax, e.g. import:::. two ways calling import functions analogue :: ::: operators . Note import functions usually (intended) side-effect altering search path, (default) import objects \"imports\" search path entry rather global environment. import package meant loaded library (output message attached), rather named make function calls expressive without need loading use, .e. designed used explicitly :: syntax, e.g. import::(pkg, x, y).","code":""},{"path":"/reference/importfunctions.html","id":"packages-vs-modules","dir":"Reference","previous_headings":"","what":"Packages vs. modules","title":"Import Objects From a Package. — from","text":"import can either used import objects either R packages R source files. .parameter ends '.R' '.r', import look source file import . source file context referred module documentation.","code":""},{"path":"/reference/importfunctions.html","id":"package-versions","dir":"Reference","previous_headings":"","what":"Package Versions","title":"Import Objects From a Package. — from","text":"import can specify package version requirements. add requirement parentheses package name (needs quoted), e.g import::(\"parallel (>= 3.2.0)\", ...). can use operators <, >, <=, >=, ==, !=. Whitespace specification irrelevant.","code":""},{"path":[]},{"path":"/reference/importfunctions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Import Objects From a Package. — from","text":"","code":"import::from(parallel, makeCluster, parLapply) import::into(\"imports:parallel\", makeCluster, parLapply, .from = parallel)"},{"path":"/news/index.html","id":"version-132900x","dir":"Changelog","previous_headings":"","what":"Version 1.3.2.900x","title":"Version 1.3.2.900x","text":"Minor bugfixes","code":""},{"path":"/news/index.html","id":"version-132","dir":"Changelog","previous_headings":"","what":"Version 1.3.2","title":"Version 1.3.2","text":"CRAN release: 2024-01-21 minor bugfix release addressing issue way method names constructed S3 imports.","code":""},{"path":"/news/index.html","id":"version-131","dir":"Changelog","previous_headings":"","what":"Version 1.3.1","title":"Version 1.3.1","text":"CRAN release: 2023-09-23 import package now default use full current set library paths, .e. result .libPaths(), versions including 1.3.0 defaulted use first entry library paths, .e. .library=.libPaths()[1L]. order loadNamespace() getNamespaceExports() changed import::(). intended bug fix, possible affects usage situations specificity library path important. two aforementioned changes implemented jointly, bug addressed second change masking bug needed fixed second change. detailed analysis can found issue #56 GitHub. regression introduced 1.3.0, prevented importing multiple scripts environment situations, now fixed. Errors occur importing modules now handled effectively. issue package documentation, correctly documenting \"_PACKAGE\" ensure -package alias added.","code":""},{"path":"/news/index.html","id":"version-130","dir":"Changelog","previous_headings":"","what":"Version 1.3.0","title":"Version 1.3.0","text":"CRAN release: 2022-05-23 import::/now support importing .symbols, regardless .character_only value, NSE never performed parameter. words, .parameter now always regular variable, can type character (indicating named environment) environment (indicating unnamed environment). Curly brackets {} longer needed, simply ignored present. import:://now new .S3 parameter, setting TRUE allows automatic detection registration S3 generics methods. initial experimental implementation, disabled default. import:://now support importing hidden objects (names prefixed period). Users aware importing objects names named function parameters may cause issues (happen well new parameters may added import package future) Minor patch import fixes bug importing library defined libPaths. namespace fixed imported earlier function definition later functions use lib.loc parameter (getNamespaceExports) can successfully reference namespace. Minor patch import fixes bug function get namespaces package:base can incorrectly substituted make_import_call. fix also applies getExportedValue, even though function less likely masked. Several documentation improvements.","code":""},{"path":"/news/index.html","id":"version-120","dir":"Changelog","previous_headings":"","what":"Version 1.2.0","title":"Version 1.2.0","text":"CRAN release: 2020-09-24 import now strict won’t allow import different environment replace existing import name location. One can now import directly environment (may attached) wrapping braces, e.g. import::(pkg, symbol, .= {environment()}) import:://now include new option, .character_only, suppresses non-standard evaluation thus allows passing object names locations variables (character strings). import:://now include new options, ..except, allow user import functions, functions except , package module. import:://now include new option, “.chdir”, specifying whether working directory changed sourcing modules import. import:://now include new option, “.directory”, import::() fixed use environment() explicitly import current environment, rather importing “” (empty string), longer works upstream changes. Passing “” “.” parameter now shorthand .= {environment()}. Using import::(), import::(), library() inside module sourced import:://parameter order import::() changed consistent import::(). change backwards compatible moved parameter (.) previously behind ellipsis, requiring use named parameters. Unit tests added various issues fixed.","code":""},{"path":"/news/index.html","id":"version-110","dir":"Changelog","previous_headings":"","what":"Version 1.1.0","title":"Version 1.1.0","text":"CRAN release: 2015-06-22 now support import objects script files, .e. kind “module”. Scripts meant expose objects import ideally side-effect free, enforced. attachments detached import, loaded namespaces remain loaded.","code":""},{"path":"/news/index.html","id":"version-102","dir":"Changelog","previous_headings":"","what":"Version 1.0.2","title":"Version 1.0.2","text":"CRAN release: 2015-04-10 can now specify library use, one library ever used single call: ambiguity imports come . distinction using double- triple colon syntax; analogously using :: ::: operators. package attached (e.g. via library) startup message informing user package meant attached. possible use functions import:: / import::: syntax.","code":""}]
