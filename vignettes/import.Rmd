---
title: "The import package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The import package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

*Stefan Holst Milton Bache. This version: June, 2020.*

![import-logo](import.png)

## Introduction
One of the most important aspects of the R ecosystem is the ease with which
extensions and new features can be developed and distributed in the form of
*packages.* The main distribution channel is the *Comprehensive R
Archive Network*, from which packages can be installed directly from
R. Another popular option is using GitHub repositories from which packages can
also be painlessly installed, e.g. using `install_github` from the 
`devtools` package. 

The `import` package provides an alternative approach to using external 
functionality in R scripts; first however, it is useful to describe the standard 
approach to clarify how `import` may serve as improvement.
The most common way to include the functionality provided by a package is to use
the `library` function:

```{r, eval = FALSE}
library(PackageA)
library(PackageB)

value1 <- function_a(...) # Supposedly this comes from PackageA, 
value2 <- function_b(...) # and this from PackageB, but who knows?!
...
```

In some situations this is fine; however there are some subtle shortcomings:

1. Packages are *attached* and *all* of their exported objects are exposed,
2. When using more packages this way, the *order* in which they are attached 
   can be important,
3. It quickly becomes *unclear* to the reader of a script which package
   certain functionality comes from, and
4. the terms "library" and "package" are often used incorrectly 
   (although a minor point, it seems to confuse somewhat).

The problem with (1) is that the search path is populated with more
objects than are needed and it is not immediately clear whether name clashes
will occur. Problem (2) refers to the case where packages export
different objects with the same names, say if `function_b` is exported in both
`PackageA` and `PackageB` above. In this case the name will 
point to the object from the package attached *last*. The earlier exposed 
objects are said to *masked*. Even if this is not a problem
when *writing* the script, an update of packages may cause this problem
later on when *executing* the script; and tracking down the resulting 
errors may be tough and time consuming. Problem (3) may appear unimportant, 
but it is not to be underestimated. Code snippets are very commonly shared
and spending time figuring out where functionality comes from is not 
a very satisfying nor value-adding activity.

To overcome the above, one may import single exported objects, one at a time, 
using the (double) "colon syntax",

```{r, eval = FALSE}
function_a <- PackageA::function_a
function_b <- PackageB::function_b
```

or functions can be prefixed with `::` when used, but this is often 
overly verbose and does not provide an easily accessible overview of what
external functionality is used in a script.

While packages form the backbone of code distribution, another option comes
in the form of *scripts*, but these are usually task specific and not
commonly used to "bundle" functionality for use in *other* scripts. In 
particular, when `source` is used to include contents from one script in 
another, once again *all* objects produced by the script will be "exposed"
and may "over populate" the working environment, masking other objects, 
if not only producing some mental clutter. Scope management is therefore not too 
comfortable when splitting functionality across files in a modular way.


The `import` package sets out to improve the way external functionality 
is *included* in your code by alleviating some of the concerns raised above by
providing an expressive way of importing object from both packages and
scripts. The latter provides a bridge between the *package* approach to
distribtion and simple stand-alone script files. This allows for the use of scripts
as *modules*, a collection og related object definitions, each of which
may be used at different places without exposing more than necessary.

## Usage
The `import` package itself should not to be attached 
(don't include it via `library`, you will get a warning). Rather, it is designed
to be expressive when using the colon syntax. A first pseudo-example is:

```{r, eval = FALSE}
import::from(magrittr, "%>%")
import::from(dplyr, mutate, keep_when = filter)
import::from(tidyr, spread)
import::from(broom, tidy)

ready_data <-
  raw_data %>% 
  mutate(var2 = fun(var1)) %>% 
  keep_when(var1 > 0) %>% 
  spread(key, value) 

linear_model <- 
  lm(var1 ~ ., data = ready_data) %>% 
  tidy
  
# ... and more code below.
```

In the above, it is clear *which* package provides *which* functions
(one could e.g. otherwise be tempted to think that `tidy` belonged to
`tidyr`). Note that ordering is irrelevant, even if `tidyr` at some point
exposes a function `tidy` after an update, as `import` is *explicit* about
importing.

It also shows that one can import multiple objects in a single
statement, and even rename objects if desired; for example, in the above 
one can imagine that `filter` from `stats` is needed later on, and so
`dplyr`'s `filter` is renamed to avoid confusion. Sometimes, it is 
not at all clear what purpose a package has; e.g. the name `magrittr` does
not immediately reveal that it's main purpose is to provide the pipe 
operator, `%>%`.

When `import::from` is used to import objects it will place them in an 
environment attached in the search path under the name "imports". This 
name is just default, and can be specified:

```{r, eval = FALSE}
import::from(dplyr, mutate, select, .into = "wrangling")

# or equivalently:
import::into("wrangling", mutate, select, .from = dplyr)

ls("wrangling") # Also viewable in Rstudio's environment browser!
# => [1] "mutate" "select"
```

Note, that the `.from` and `.into` arguments are prefixed by a dot to
clearly distinguish them from other named arguments. The two 
alternatives above are equivalent (the choice is a matter of preferece).

If it is desired to import objects directly into the current environment, 
this can be accomplished by `import::here`. This is particularly 
useful when importing inside a function definition, or module scripts as
described below.

## "Module" scripts
Suppose that you have some related functionality that you wish to bundle, and
that authoring a full package seems excessive or inappropriate 
for the specific task, for example bundling related UI components for a `shiny` 
application. One option with `import` is to author a module (script), say as outlined
below:

```{r, eval=FALSE}
# File: foo.R
# Desc: Functionality related to foos.
# Imports from other_resources.R
import::here(fun_a, fun_b, .from = "other_resources.R")

internal_fun <- function(...) ...

fun_c <- function(...) 
{
  ...
  a <- fun_a(...)
  i <- internal_fun(...)
  ...
}

fun_d <- function(...) ...
```

Then in another file we need `fun_c`:

```{r, eval = FALSE}
# File: bar.R
# Desc: Functionality related to bars. 
# Imports from foo.R
import::here(fun_c, .from = "foo.R")
...
```

In the above, *only* `fun_c` is visible inside `bar.R`. The 
functions on which it depends exist, but are not exposed. 
Also, note that imported scripts may themselves import. To 
avoid imports becoming global, it is suggested to 
use `import::here` rather than `import::from`, in which case
imports are only exposed to the module itself.

When importing from a module, it is sourced into an environment
managed by `import`, and will not be sourced again upon subsequent 
imports (unless the file has changed). For example, in a `shiny` 
application, importing some
objects in `server.R` and others in `ui.R` from the same module will not
cause it to be sourced twice.

## Advanced usage and the `.character_only` parameter
The `import` package uses non-standard evaluation (NSE) in order to allow the 
names of packages and functions to be listed without quoting them. This
makes some common use-cases very straightforward, but can get in the 
way of more programmatic usages.

This is where the `.character_only` parameter comes in handy. By setting
`.character_only=TRUE`, all NSE of the `.from`, 
`.into` and the `...` parameters is disabled (other parameters are 
always evaluated in a standard way). Instead, the parameters are processed
as character vectors containing the relevant values. It is useful to 
examine some examples of how this can be helpful.

### Programmatically selecting the objects to import
It is not always know in advance which objects to import from a given
package. For example, assume we have a list of objects from the 
`broom` package that we need to import, we can do it as follows:

```{r, eval = FALSE}
objects <- c("tidy", "glance", "augment")
import::from("broom", objects, .character_only=TRUE)
```

This will import the three functions specified in the `objects` vector.
It is worth noting that because `.character_only` disables NSE on *all*
parameters, the name of the package must now be quoted.

One common use case is when one wants to import all objects except one
or a few, because of conflicts with other packages. Should one, for 
example, want to use the `stats` versions of the `filter()` and `lag()`
functions, but import all the other functions in the `dplyr` package,
one could do it like this:

```{r, eval = FALSE}
objects <- setdiff(getNamespaceExports("dplyr"), c("filter","lag"))
import::from("dplyr", objects, .character_only=TRUE)
```

## Programmatically selecting the location of a module
The same approach can be used when the directory of the source
file for a module is not known in advance. This can be useful
when the original source file is not always run with the original
working directory, but one still does not want to specify a 
hard-coded absolute path, but to determine it at run time:

```{r, eval = FALSE}
mymodule <- file.path(mypath,"module.R")
import::from(mymodule, "myfunction", .character_only=TRUE)
```

Again, note that now the name of the function must be quoted because
NSE is disabled on all parameters.

The `here` package is useful in many circumstances like this; it 
allows the setting of a "root" directory for a project and by using
the `here::here()` function to figure out the correct directory, 
regardless of the working directory.

```{r, eval = FALSE}
import::from(here::here("src/utils/module.R")), "myfunction", .character_only=TRUE)
```

Note that `here::here()` has no relation to `import::here()` despite
the similarity in names.

## Importing from a URL
Another case where `.character_only` comes in handy is when one
wants to import some functions from a URL. While `import` does 
not allow direct importing from a URL (because of difficult 
questions about when a URL target has changes, whether to 
download a file and other things), it easy to achieve the desired
result by using the `pins` package (whose raison d'etre is to 
resolve such difficult questions). A simple example follows:

```{r, eval = FALSE}
url <- "https://gist.githubusercontent.com/noamross/378884a472b5ef58c6cf/raw/1cd3a47158427ef7e2faa897d32821f14fa19bfd/test.R"
import::from(pins::pin(url), "myfunc", .character_only=TRUE)
myfunc(3)
#> [1] 4
```{r, eval = FALSE}
